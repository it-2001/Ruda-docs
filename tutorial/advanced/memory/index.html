<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>4. Memory Management - Ruda</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Memory Management", url: "#_top", children: [
              {title: "Allocating memory", url: "#allocating-memory" },
              {title: "Freeing memory", url: "#freeing-memory" },
              {title: "Working with Garbage collector", url: "#working-with-garbage-collector" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../cheatsheet/keywords/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../cheatsheet/keywords/" class="btn btn-xs btn-link">
        Keywords
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../overloads/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../overloads/" class="btn btn-xs btn-link">
        3. Overloading
      </a>
    </div>
    
  </div>

    

    <h1 id="memory-management">Memory Management</h1>
<p>Ruda uses a garbage collector to manage memory. This means that you don't have to worry about freeing memory yourself. However, this does not mean that you can't manage memory yourself. Ruda provides a way to allocate and free memory manually.</p>
<h2 id="allocating-memory">Allocating memory</h2>
<p>You can allocate memory using the <code>new</code> keyword. This allocates memory on the heap and returns a pointer to the allocated memory.</p>
<pre><code class="language-ruda">let x = new 5
</code></pre>
<p>Heap can be allocated for any type, including structs, enums, and arrays.</p>
<pre><code class="language-ruda">struct Foo {
    x: int,
}

impl Foo {
    fun Foo(x: int) {
        self.x = x
    }
}

let foo = new Foo(5)
</code></pre>
<h2 id="freeing-memory">Freeing memory</h2>
<p>Freeing memory will be part of the standard library in the future. For now, you just need to rely on the garbage collector (not that it doesn't do a good job).</p>
<h2 id="working-with-garbage-collector">Working with Garbage collector</h2>
<p>Many languages implement GC to ensure memory safety and ease the development cycle. While all this is also true for Ruda, it takes a slightly different approach. Garbage collector manages memory, but the user manages the garbage collector. It is as easy as calling a method through the memory API in standard library.</p>
<pre><code class="language-ruda">import &quot;#memory&quot;

fun main(){
    memory.Gc.sweep()
}
</code></pre>
<blockquote>
<p>You right now: "<em>WHY? This has to be a step bacwards..</em>"</p>
</blockquote>
<p>You may be right. The difference between good and bad GC is that you do not even notice the good one, therefore my implementation would be the worst possible. In the real world things are not so simple for anyone to decide whats the best memory model. Each has their uses. My offers ease of use combined with controll. In garbage collected languages you often dont know when the collector starts sweeping. This results in uncontrollable and unwanted lag spikes. Ruda offers more direct memory access while also hiding it when necessary.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../cheatsheet/keywords/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../cheatsheet/keywords/" class="btn btn-xs btn-link">
        Keywords
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../overloads/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../overloads/" class="btn btn-xs btn-link">
        3. Overloading
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>