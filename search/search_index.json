{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ruda Ruda is a general purpose programming language that aims to be as straightforward as possible. Extra focus is put on the following: Simplicity : Ruda is designed to be easy to learn and use. It has a simple syntax and a small number of keywords. Safety : Ruda is a statically typed language. It also has a built-in garbage collector that allows you to take charge of memory management if needed. Flexibility : Ruda is a multiparadigm language that allows you to write code in a functional, imperative or object-oriented style. Or maybe a mix of all three. Getting started Installation Hello, world! First program","title":"Home"},{"location":"#ruda","text":"Ruda is a general purpose programming language that aims to be as straightforward as possible. Extra focus is put on the following: Simplicity : Ruda is designed to be easy to learn and use. It has a simple syntax and a small number of keywords. Safety : Ruda is a statically typed language. It also has a built-in garbage collector that allows you to take charge of memory management if needed. Flexibility : Ruda is a multiparadigm language that allows you to write code in a functional, imperative or object-oriented style. Or maybe a mix of all three.","title":"Ruda"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installation","text":"","title":"Installation"},{"location":"#hello-world","text":"","title":"Hello, world!"},{"location":"#first-program","text":"","title":"First program"},{"location":"installation/","text":"Installation Important: Ruda installer is currently under development. This guide will be updated once it is ready. Building from source Requirements Rust Python Steps 1. Clone the repository git clone https://github.com/it-2001/Ruda 2. Run the build script cd Ruda py ruda_build.py This will create a build directory containing the necessary files. 3. Add the build/bin directory to your PATH environment variable See this guide for instructions on how to do this on Windows. 4. Create a new environment variable called RUDA_PATH and set it to the build directory 5. Run ruda to check if everything is working ruda -V If everything is working, you should see the following output: Ruda pacman x.x.x","title":"Installation"},{"location":"installation/#installation","text":"Important: Ruda installer is currently under development. This guide will be updated once it is ready.","title":"Installation"},{"location":"installation/#building-from-source","text":"","title":"Building from source"},{"location":"installation/#requirements","text":"Rust Python","title":"Requirements"},{"location":"installation/#steps","text":"","title":"Steps"},{"location":"installation/#1-clone-the-repository","text":"git clone https://github.com/it-2001/Ruda","title":"1. Clone the repository"},{"location":"installation/#2-run-the-build-script","text":"cd Ruda py ruda_build.py This will create a build directory containing the necessary files.","title":"2. Run the build script"},{"location":"installation/#3-add-the-buildbin-directory-to-your-path-environment-variable","text":"See this guide for instructions on how to do this on Windows.","title":"3. Add the build/bin directory to your PATH environment variable"},{"location":"installation/#4-create-a-new-environment-variable-called-ruda_path-and-set-it-to-the-build-directory","text":"","title":"4. Create a new environment variable called RUDA_PATH and set it to the build directory"},{"location":"installation/#5-run-ruda-to-check-if-everything-is-working","text":"ruda -V If everything is working, you should see the following output: Ruda pacman x.x.x","title":"5. Run ruda to check if everything is working"},{"location":"cheatsheet/keywords/","text":"Keywords Here is a list of all the keywords in the language. Variable declaration Keyword Description Example reference let Declares a variable let x = 10 Variables const Declares a constant const x = 10 Constants type Declares a type alias type Foo = int Type Aliases Control flow Keyword Description Example reference if Executes a block of code if a condition is true. if x == 10 { ... } If Statements else Executes a block of code if a condition is false. if x == 10 { ... } else { ... } Else Statements else if Executes a block of code if a condition is false and another condition is true. if x == 10 { ... } else if x == 20 { ... } Else If Statements switch Executes a block of code based on the value of an expression. switch x { ... } Switch Statements Loops Keyword Description Example reference while Executes a block of code while a condition is true. while x < 10 { ... } While Loops for Executes a block of code for each element in a collection. for x in [1,2,3] { ... } For Loops loop Executes a block of code forever. loop { ... } Loop Statements break Breaks out of a loop. break Break Statements continue Skips the rest of the current iteration of a loop. continue Continue Statements Functions Keyword Description Example reference fun Declares a function. fun foo() { ... } Functions return Returns a value from a function. return 10 Return Statements overload Declares a function that overloads an operator. overload + (other: Foo): Foo { ... } Operator Overloading Comments Keyword Description Example reference // Single line comment // this is a comment Comments /* */ Multi line comment /* this is a comment */ Comments Non Primitive Types Keyword Description Example reference struct Declares a struct. struct Foo { a: int } Structs enum Declares an enum. enum Foo { Right, Left } Enums impl Implements methods or traits for a type. impl Foo { fun foo() { ... } } Methods trait Declares a trait. trait Foo { fun foo() } Traits import Imports a module. import \"std.io\" Modules Memory Management Keyword Description Example reference new Allocates memory on the heap. let x = new 5 Memory Management as Casts a value to a different type. let x = 5 as float Casting ? Checks if a value is null. if x? { ... } Optionals Error Handling Keyword Description Example reference try Executes a block of code that can throw an error. try { ... } Error Handling catch Handles an error that occured inside a try block. catch err { ... } Catch yeet Throws an error. yeet Error(\"error message\") Yeet error Declares an error type. error MyError { ... } Error Declaration ! Bang operator. let x = foo()! Bang","title":"Keywords"},{"location":"cheatsheet/keywords/#keywords","text":"Here is a list of all the keywords in the language.","title":"Keywords"},{"location":"cheatsheet/keywords/#variable-declaration","text":"Keyword Description Example reference let Declares a variable let x = 10 Variables const Declares a constant const x = 10 Constants type Declares a type alias type Foo = int Type Aliases","title":"Variable declaration"},{"location":"cheatsheet/keywords/#control-flow","text":"Keyword Description Example reference if Executes a block of code if a condition is true. if x == 10 { ... } If Statements else Executes a block of code if a condition is false. if x == 10 { ... } else { ... } Else Statements else if Executes a block of code if a condition is false and another condition is true. if x == 10 { ... } else if x == 20 { ... } Else If Statements switch Executes a block of code based on the value of an expression. switch x { ... } Switch Statements","title":"Control flow"},{"location":"cheatsheet/keywords/#loops","text":"Keyword Description Example reference while Executes a block of code while a condition is true. while x < 10 { ... } While Loops for Executes a block of code for each element in a collection. for x in [1,2,3] { ... } For Loops loop Executes a block of code forever. loop { ... } Loop Statements break Breaks out of a loop. break Break Statements continue Skips the rest of the current iteration of a loop. continue Continue Statements","title":"Loops"},{"location":"cheatsheet/keywords/#functions","text":"Keyword Description Example reference fun Declares a function. fun foo() { ... } Functions return Returns a value from a function. return 10 Return Statements overload Declares a function that overloads an operator. overload + (other: Foo): Foo { ... } Operator Overloading","title":"Functions"},{"location":"cheatsheet/keywords/#comments","text":"Keyword Description Example reference // Single line comment // this is a comment Comments /* */ Multi line comment /* this is a comment */ Comments","title":"Comments"},{"location":"cheatsheet/keywords/#non-primitive-types","text":"Keyword Description Example reference struct Declares a struct. struct Foo { a: int } Structs enum Declares an enum. enum Foo { Right, Left } Enums impl Implements methods or traits for a type. impl Foo { fun foo() { ... } } Methods trait Declares a trait. trait Foo { fun foo() } Traits import Imports a module. import \"std.io\" Modules","title":"Non Primitive Types"},{"location":"cheatsheet/keywords/#memory-management","text":"Keyword Description Example reference new Allocates memory on the heap. let x = new 5 Memory Management as Casts a value to a different type. let x = 5 as float Casting ? Checks if a value is null. if x? { ... } Optionals","title":"Memory Management"},{"location":"cheatsheet/keywords/#error-handling","text":"Keyword Description Example reference try Executes a block of code that can throw an error. try { ... } Error Handling catch Handles an error that occured inside a try block. catch err { ... } Catch yeet Throws an error. yeet Error(\"error message\") Yeet error Declares an error type. error MyError { ... } Error Declaration ! Bang operator. let x = foo()! Bang","title":"Error Handling"},{"location":"cheatsheet/operators/","text":"Operators Here is a list of all the operators in the language. Arithmetic Operators Operator Description Example + Adds two values 5 + 5 = 10 - Subtracts two values 5 - 5 = 0 * Multiplies two values 5 * 5 = 25 / Divides two values 5 / 5 = 1 % Returns the remainder of two values 7 % 5 = 2 Comparison Operators Operator Description Example == Returns true if two values are equal 5 == 5 = true != Returns true if two values are not equal 5 != 5 = false < Returns true if the first value is less than the second value 5 < 6 = true > Returns true if the first value is greater than the second value 5 > 6 = false <= Returns true if the first value is less than or equal to the second value 5 <= 6 = true >= Returns true if the first value is greater than or equal to the second value 5 >= 6 = false Logical Operators Operator Description Example && Returns true if both values are true true && false = false || Returns true if either value is true true || false = true ! Returns true if the value is false !true = false Error Handling Operators Note: Also have a look at Bang . Operator Description Example ? Returns whether or not an expression is null x? ! Forwards an error that occurs in a function foo()! Bitwise Operators Not implemented yet. Assignment Operators Operator Description Example = Assigns a value to a variable x = 5 += Adds a value to a variable x += 5 -= Subtracts a value from a variable x -= 5 *= Multiplies a variable by a value x *= 5 /= Divides a variable by a value x /= 5 Other Operators Operator Description Example . Accesses a member of a struct foo.bar [] Accesses an element of an array foo[0] () Calls a function foo() : Declares a type let x: int = 5 ; Ends a statement let x = 5; Order of Operations Order of operations is the order in which operators are evaluated. For example, in the expression 5 + 5 * 5 , the multiplication operator ( * ) is evaluated before the addition operator ( + ). This means that the expression is evaluated as 5 + (5 * 5) , which equals 30 . The order of operations is as follows: Parentheses: () Unary operators: ! , - , new Multiplication and division: * , / , % Addition and subtraction: + , - Comparison operators: == , != , < , > , <= , >= Logical operators: && , ||","title":"Operators"},{"location":"cheatsheet/operators/#operators","text":"Here is a list of all the operators in the language.","title":"Operators"},{"location":"cheatsheet/operators/#arithmetic-operators","text":"Operator Description Example + Adds two values 5 + 5 = 10 - Subtracts two values 5 - 5 = 0 * Multiplies two values 5 * 5 = 25 / Divides two values 5 / 5 = 1 % Returns the remainder of two values 7 % 5 = 2","title":"Arithmetic Operators"},{"location":"cheatsheet/operators/#comparison-operators","text":"Operator Description Example == Returns true if two values are equal 5 == 5 = true != Returns true if two values are not equal 5 != 5 = false < Returns true if the first value is less than the second value 5 < 6 = true > Returns true if the first value is greater than the second value 5 > 6 = false <= Returns true if the first value is less than or equal to the second value 5 <= 6 = true >= Returns true if the first value is greater than or equal to the second value 5 >= 6 = false","title":"Comparison Operators"},{"location":"cheatsheet/operators/#logical-operators","text":"Operator Description Example && Returns true if both values are true true && false = false || Returns true if either value is true true || false = true ! Returns true if the value is false !true = false","title":"Logical Operators"},{"location":"cheatsheet/operators/#error-handling-operators","text":"Note: Also have a look at Bang . Operator Description Example ? Returns whether or not an expression is null x? ! Forwards an error that occurs in a function foo()!","title":"Error Handling Operators"},{"location":"cheatsheet/operators/#bitwise-operators","text":"Not implemented yet.","title":"Bitwise Operators"},{"location":"cheatsheet/operators/#assignment-operators","text":"Operator Description Example = Assigns a value to a variable x = 5 += Adds a value to a variable x += 5 -= Subtracts a value from a variable x -= 5 *= Multiplies a variable by a value x *= 5 /= Divides a variable by a value x /= 5","title":"Assignment Operators"},{"location":"cheatsheet/operators/#other-operators","text":"Operator Description Example . Accesses a member of a struct foo.bar [] Accesses an element of an array foo[0] () Calls a function foo() : Declares a type let x: int = 5 ; Ends a statement let x = 5;","title":"Other Operators"},{"location":"cheatsheet/operators/#order-of-operations","text":"Order of operations is the order in which operators are evaluated. For example, in the expression 5 + 5 * 5 , the multiplication operator ( * ) is evaluated before the addition operator ( + ). This means that the expression is evaluated as 5 + (5 * 5) , which equals 30 . The order of operations is as follows: Parentheses: () Unary operators: ! , - , new Multiplication and division: * , / , % Addition and subtraction: + , - Comparison operators: == , != , < , > , <= , >= Logical operators: && , ||","title":"Order of Operations"},{"location":"cheatsheet/syntax/","text":"Ruda for busy people In this cheatsheet, you'll find a quick overview of the Ruda language. It's not meant to be a complete reference, but rather a quick reference for the most important features of the language. // This is a comment /* This is a multi-line comment */ // Imports import \"std.io\" import \"std.math\" as mt // Constants const PI = 3.14 // Type aliases type i32 = int fun main() { // Variables let x = 5 let z: int = x + 50 // Arrays let arr = [1, 2, 3, 4, 5] // [1, 2, 3, 4, 5] let arr: [int; 5] = [1; 5] // [1, 1, 1, 1, 1] // If statements if x > y { io.println(\"x is greater than y\") } else if x < y { io.println(\"x is less than y\") } else { io.println(\"x is equal to y\") } // Loops for i in math.range(0, 10) { io.println(i) // continue and break if i == 5 { continue } if i == 8 { break } } // 0, 1, 2, 3, 4, 6, 7 // Switch switch x { 0 { io.println(\"x is 0\") }, 1 { io.println(\"x is 1\") }, _ { io.println(\"x is not 0 or 1\") } } // Error handling let result; try { result = math.sqrt(-1) } catch err: math.MathError { io.println(\"math error occurred\") } catch err { io.println(\"error occurred, we don't care what kind\") } // Error declaration error MathError(msg: string) { message: msg, // optional, defaults to \"something went wrong\" code: 1 // optional, defaults to 1 } // Error throwing fun sqrt(x: float): float { if x < 0 { yeet math.MathError(\"x must be positive\") } return math.sqrt(x) } // yes you read that right, it's called yeet // Pointers let x = 5 let y = &x let z = *y } // Functions fun add(x: int, y: int): int { return x + y } // Structs struct Point { x: int, y: int } // Enums enum Color { Red, Green = 10, Blue = 100, } // Traits trait Drawable { fun draw() } // Methods impl Point { constructor(x: int, y: int) { self.x = x self.y = y } fun draw(&self) { io.println(\"Drawing point at\") } } // Generics fun add<T(Math.Arithmetics)>(x: T, y: T): T { return x + y } // Implementing traits for types impl Point trait math.Arithmetics { fun add(&self, other: &Point): Point { return Point(self.x + other.x, self.y + other.y) } /* In this case you would need to finish the implementation of the trait by implementing the other methods of the trait. */ }","title":"Syntax"},{"location":"cheatsheet/syntax/#ruda-for-busy-people","text":"In this cheatsheet, you'll find a quick overview of the Ruda language. It's not meant to be a complete reference, but rather a quick reference for the most important features of the language. // This is a comment /* This is a multi-line comment */ // Imports import \"std.io\" import \"std.math\" as mt // Constants const PI = 3.14 // Type aliases type i32 = int fun main() { // Variables let x = 5 let z: int = x + 50 // Arrays let arr = [1, 2, 3, 4, 5] // [1, 2, 3, 4, 5] let arr: [int; 5] = [1; 5] // [1, 1, 1, 1, 1] // If statements if x > y { io.println(\"x is greater than y\") } else if x < y { io.println(\"x is less than y\") } else { io.println(\"x is equal to y\") } // Loops for i in math.range(0, 10) { io.println(i) // continue and break if i == 5 { continue } if i == 8 { break } } // 0, 1, 2, 3, 4, 6, 7 // Switch switch x { 0 { io.println(\"x is 0\") }, 1 { io.println(\"x is 1\") }, _ { io.println(\"x is not 0 or 1\") } } // Error handling let result; try { result = math.sqrt(-1) } catch err: math.MathError { io.println(\"math error occurred\") } catch err { io.println(\"error occurred, we don't care what kind\") } // Error declaration error MathError(msg: string) { message: msg, // optional, defaults to \"something went wrong\" code: 1 // optional, defaults to 1 } // Error throwing fun sqrt(x: float): float { if x < 0 { yeet math.MathError(\"x must be positive\") } return math.sqrt(x) } // yes you read that right, it's called yeet // Pointers let x = 5 let y = &x let z = *y } // Functions fun add(x: int, y: int): int { return x + y } // Structs struct Point { x: int, y: int } // Enums enum Color { Red, Green = 10, Blue = 100, } // Traits trait Drawable { fun draw() } // Methods impl Point { constructor(x: int, y: int) { self.x = x self.y = y } fun draw(&self) { io.println(\"Drawing point at\") } } // Generics fun add<T(Math.Arithmetics)>(x: T, y: T): T { return x + y } // Implementing traits for types impl Point trait math.Arithmetics { fun add(&self, other: &Point): Point { return Point(self.x + other.x, self.y + other.y) } /* In this case you would need to finish the implementation of the trait by implementing the other methods of the trait. */ }","title":"Ruda for busy people"},{"location":"extensions/about/","text":"Ruda extensions Extension is a native library, that uses the Ruda ABI. In other words it is a library (.dll, .so), that is compatible with Ruda applications. Extensions run independently to the Ruda binary, meaning that they can use the computer resources directly. This allows them to read files, write to console, send http requests, etc. You are probably using extensions in all of your Ruda programs, since without access to the computer, your appication would be useless. Even if you wrote only \"useless\" programs, Ruda still uses extensions under the hood, to replace some missing instructions. For example if you copy a string, it runs a certain procedure from the core extension. In this chapter you will learn how to write your own extensions. Extensions support only the Rust programming language, it is recommended to know at least basic Rust.","title":"Ruda extensions"},{"location":"extensions/about/#ruda-extensions","text":"Extension is a native library, that uses the Ruda ABI. In other words it is a library (.dll, .so), that is compatible with Ruda applications. Extensions run independently to the Ruda binary, meaning that they can use the computer resources directly. This allows them to read files, write to console, send http requests, etc. You are probably using extensions in all of your Ruda programs, since without access to the computer, your appication would be useless. Even if you wrote only \"useless\" programs, Ruda still uses extensions under the hood, to replace some missing instructions. For example if you copy a string, it runs a certain procedure from the core extension. In this chapter you will learn how to write your own extensions. Extensions support only the Rust programming language, it is recommended to know at least basic Rust.","title":"Ruda extensions"},{"location":"extensions/starting/","text":"Starting Ruda source code has a template for creating extensions, so we will use it Extension system will most likely have some small changes before full release. Keep that in mind. Got to Ruda and clone the repository. We will need the source code to compile the extension. (this will be simplified later). Copy stdlib/base/ to the same directory and rename it to test . This is the root of your project. Before starting, go to Cargo.toml and change the name of your project to test . This will give you this: [package] name = \"test\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] runtime = {path = \"../../vm/runtime\"} [lib] path = \"lib.rs\" crate-type = [\"cdylib\"] [profile.dev] opt-level = 3 debug = false If everything works, you should be able to compile test using cargo build --release . This will output your extension to target/release/test.dll ( libtest.so on Linux). Take the extension file and place it to some Ruda project root directory. Open Ruda.toml file and add: [binaries] test = \"test.dll\" Compile the project ruda run . This should run.","title":"Starting"},{"location":"extensions/starting/#starting","text":"Ruda source code has a template for creating extensions, so we will use it Extension system will most likely have some small changes before full release. Keep that in mind. Got to Ruda and clone the repository. We will need the source code to compile the extension. (this will be simplified later). Copy stdlib/base/ to the same directory and rename it to test . This is the root of your project. Before starting, go to Cargo.toml and change the name of your project to test . This will give you this: [package] name = \"test\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] runtime = {path = \"../../vm/runtime\"} [lib] path = \"lib.rs\" crate-type = [\"cdylib\"] [profile.dev] opt-level = 3 debug = false If everything works, you should be able to compile test using cargo build --release . This will output your extension to target/release/test.dll ( libtest.so on Linux). Take the extension file and place it to some Ruda project root directory. Open Ruda.toml file and add: [binaries] test = \"test.dll\" Compile the project ruda run . This should run.","title":"Starting"},{"location":"pacman/building/","text":"Build Project This includes all the commands that could be used to build a project. Build To build a project, run ruda build or ruda build <path> . This will build the project in the current directory (or specified) and creates: A target directory, which contains the compiled code + compiler artifacts. Options --profile <profile> : Sets the profile of the build. Can be any of the specified profiles in the Ruda.toml file. --help : Prints help information. Run To run a project, run ruda run or ruda run <path> . This is the same as running ruda build and then running the compiled code. Only difference is that you can specify arguments to the program by adding them after the command (e.g. ruda run -- arg0 arg1 ).","title":"Building"},{"location":"pacman/building/#build-project","text":"This includes all the commands that could be used to build a project.","title":"Build Project"},{"location":"pacman/building/#build","text":"To build a project, run ruda build or ruda build <path> . This will build the project in the current directory (or specified) and creates: A target directory, which contains the compiled code + compiler artifacts.","title":"Build"},{"location":"pacman/building/#options","text":"--profile <profile> : Sets the profile of the build. Can be any of the specified profiles in the Ruda.toml file. --help : Prints help information.","title":"Options"},{"location":"pacman/building/#run","text":"To run a project, run ruda run or ruda run <path> . This is the same as running ruda build and then running the compiled code. Only difference is that you can specify arguments to the program by adding them after the command (e.g. ruda run -- arg0 arg1 ).","title":"Run"},{"location":"pacman/configuration/","text":"Configuring Ruda Project The Ruda.toml file is the configuration file for Ruda projects. It contains information about the project, such as the name, version, dependencies, etc. When you create new project using ruda init , it will create a Ruda.toml file with the following content: author = \"author\" license = \"MIT\" name = \"project\" runtime = \"latest\" version = \"0.1.0\" kind = \"bin\" description = \"description\" 3rdparty = \"allow\" Some of the fields are self-explanatory, but some of them are not. So let's go over the confusing ones. runtime : The version of the Ruda runtime to use. Can be latest or x.x.x . kind : The kind of the project. Can be bin or lib . 3rdparty : Whether to allow 3rd party dependencies. Can be: allow : Allow 3rd party dependencies. std : Allow only dependencies from the standard library. sandboxed : Allow only dependencies from the standard library that are considered safe. deny : Deny any dependencies, including the standard library. Dependencies Dependencies are specified in the [dependencies] section of the Ruda.toml file. [dependencies] algebra = \"https://git/repository/algebra.git\" The name of the dependency is the name of the package. The value is the URL to the Git repository of the package. You can also specify additional options for the dependency: [dependencies] algebra = { path = \"./algebra\", version = \"0.1.0\", profile = \"default\", 3rdparty = \"allow\" } path : The path to the package. Can be a local path or a URL to a Git repository. version : The version of the package to use. Can be latest or x.x.x . profile : The profile of the package to use. Can be any of the specified profiles in the Ruda.toml file. 3rdparty : Sets the 3rd party policy for the package and its dependencies. Profiles Profiles are specified in the [profiles] section of the Ruda.toml file. [profiles.embed] 3rdparty = \"deny\" Global Configuration All projects share the same global configuration, which is located in the path/to/ruda/Ruda.toml file. If you do not specify a field in the project configuration, it will use the value from the global configuration.","title":"Configuration"},{"location":"pacman/configuration/#configuring-ruda-project","text":"The Ruda.toml file is the configuration file for Ruda projects. It contains information about the project, such as the name, version, dependencies, etc. When you create new project using ruda init , it will create a Ruda.toml file with the following content: author = \"author\" license = \"MIT\" name = \"project\" runtime = \"latest\" version = \"0.1.0\" kind = \"bin\" description = \"description\" 3rdparty = \"allow\" Some of the fields are self-explanatory, but some of them are not. So let's go over the confusing ones. runtime : The version of the Ruda runtime to use. Can be latest or x.x.x . kind : The kind of the project. Can be bin or lib . 3rdparty : Whether to allow 3rd party dependencies. Can be: allow : Allow 3rd party dependencies. std : Allow only dependencies from the standard library. sandboxed : Allow only dependencies from the standard library that are considered safe. deny : Deny any dependencies, including the standard library.","title":"Configuring Ruda Project"},{"location":"pacman/configuration/#dependencies","text":"Dependencies are specified in the [dependencies] section of the Ruda.toml file. [dependencies] algebra = \"https://git/repository/algebra.git\" The name of the dependency is the name of the package. The value is the URL to the Git repository of the package. You can also specify additional options for the dependency: [dependencies] algebra = { path = \"./algebra\", version = \"0.1.0\", profile = \"default\", 3rdparty = \"allow\" } path : The path to the package. Can be a local path or a URL to a Git repository. version : The version of the package to use. Can be latest or x.x.x . profile : The profile of the package to use. Can be any of the specified profiles in the Ruda.toml file. 3rdparty : Sets the 3rd party policy for the package and its dependencies.","title":"Dependencies"},{"location":"pacman/configuration/#profiles","text":"Profiles are specified in the [profiles] section of the Ruda.toml file. [profiles.embed] 3rdparty = \"deny\"","title":"Profiles"},{"location":"pacman/configuration/#global-configuration","text":"All projects share the same global configuration, which is located in the path/to/ruda/Ruda.toml file. If you do not specify a field in the project configuration, it will use the value from the global configuration.","title":"Global Configuration"},{"location":"pacman/debugging/","text":"Debugging Locate If you think there is a problem with the source of included libraries, you can locate them by running ruda locate <name> or ruda locate <git_url> . This will print the path to the source code of the library. Example: // Ruda.toml [dependencies] algebra = \"https://git/repository/algebra.git\" ruda locate algebra Output: /path/to/ruda/packages/author/algebra Then you can open the source code in your editor and debug it. No args If you run ruda locate without any arguments, it will print the path to the Ruda directory. To get path to the Ruda packages directory, run ruda locate and append /packages to the path. Restore If you think there is a problem with the compiler artifacts, you can restore them by running ruda restore . This will remove the target directory. Options --help : Prints help information. --profile <profile> : Sets the profile of the build. Can be any of the specified profiles in the Ruda.toml file. --compile : Compiles the project after restoring the artifacts. --run : Runs the project after restoring the artifacts. Also feel free to report any issues you find with the compiler or standard library on the GitHub repository","title":"Debugging"},{"location":"pacman/debugging/#debugging","text":"","title":"Debugging"},{"location":"pacman/debugging/#locate","text":"If you think there is a problem with the source of included libraries, you can locate them by running ruda locate <name> or ruda locate <git_url> . This will print the path to the source code of the library. Example: // Ruda.toml [dependencies] algebra = \"https://git/repository/algebra.git\" ruda locate algebra Output: /path/to/ruda/packages/author/algebra Then you can open the source code in your editor and debug it.","title":"Locate"},{"location":"pacman/debugging/#no-args","text":"If you run ruda locate without any arguments, it will print the path to the Ruda directory. To get path to the Ruda packages directory, run ruda locate and append /packages to the path.","title":"No args"},{"location":"pacman/debugging/#restore","text":"If you think there is a problem with the compiler artifacts, you can restore them by running ruda restore . This will remove the target directory.","title":"Restore"},{"location":"pacman/debugging/#options","text":"--help : Prints help information. --profile <profile> : Sets the profile of the build. Can be any of the specified profiles in the Ruda.toml file. --compile : Compiles the project after restoring the artifacts. --run : Runs the project after restoring the artifacts. Also feel free to report any issues you find with the compiler or standard library on the GitHub repository","title":"Options"},{"location":"pacman/help/","text":"Ruda Package Manager The Ruda Package Manager is a tool for managing packages written in Ruda. It is used to install, update, remove and search for It comes with the Ruda development kit and is installed by default. It is not a bad idea to learn a thing or two about the package manager, sice it is the main way to interact with your Ruda projects. Help To get help on the package manager, run ruda help or ruda <command> -h . Version To get the version of the package manager, run ruda -V . Initialize a project To initialize a project, run ruda init or ruda init <path> . This will use the current directory (or specified) as the project directory and creates: A Ruda.toml file, which contains the project configuration. A src directory, which contains the source code of the project. A src/main.rd file, which contains the main function of the project. A .gitignore file, which contains the files that should be ignored by Git. Options --name <name> : Sets the name of the project. --verison <version> : Sets the version of the project. --kind <kind> : Sets the kind of the project. Can be bin or lib . --author <author> : Sets the author of the project. --help : Prints help information.","title":"Help"},{"location":"pacman/help/#ruda-package-manager","text":"The Ruda Package Manager is a tool for managing packages written in Ruda. It is used to install, update, remove and search for It comes with the Ruda development kit and is installed by default. It is not a bad idea to learn a thing or two about the package manager, sice it is the main way to interact with your Ruda projects.","title":"Ruda Package Manager"},{"location":"pacman/help/#help","text":"To get help on the package manager, run ruda help or ruda <command> -h .","title":"Help"},{"location":"pacman/help/#version","text":"To get the version of the package manager, run ruda -V .","title":"Version"},{"location":"pacman/help/#initialize-a-project","text":"To initialize a project, run ruda init or ruda init <path> . This will use the current directory (or specified) as the project directory and creates: A Ruda.toml file, which contains the project configuration. A src directory, which contains the source code of the project. A src/main.rd file, which contains the main function of the project. A .gitignore file, which contains the files that should be ignored by Git.","title":"Initialize a project"},{"location":"pacman/help/#options","text":"--name <name> : Sets the name of the project. --verison <version> : Sets the version of the project. --kind <kind> : Sets the kind of the project. Can be bin or lib . --author <author> : Sets the author of the project. --help : Prints help information.","title":"Options"},{"location":"pacman/packages/","text":"Packages Install Installed packages are shared between all projects. To install a package, run ruda install <git_url> . This will clone the repository and add it to the list of installed packages. Options --help : Prints help information. --version <version> : Sets the version of the package to install. Remove To remove a package, run ruda remove <git_url> . This will remove the package from the list of installed packages. Options --help : Prints help information. --version <version> : Sets the version of the package to remove.","title":"Packages"},{"location":"pacman/packages/#packages","text":"","title":"Packages"},{"location":"pacman/packages/#install","text":"Installed packages are shared between all projects. To install a package, run ruda install <git_url> . This will clone the repository and add it to the list of installed packages.","title":"Install"},{"location":"pacman/packages/#options","text":"--help : Prints help information. --version <version> : Sets the version of the package to install.","title":"Options"},{"location":"pacman/packages/#remove","text":"To remove a package, run ruda remove <git_url> . This will remove the package from the list of installed packages.","title":"Remove"},{"location":"pacman/packages/#options_1","text":"--help : Prints help information. --version <version> : Sets the version of the package to remove.","title":"Options"},{"location":"projects/number-guessing-game/","text":"Number guessing game This is probably your first time writing a program in Ruda. Good luck! What are we building? In this project you will create a number guessing game. The computer will think of a predefined number between 1 and 100 and you will try to guess it. The computer will tell you if your guess is too high or too low. Requirements The user should be able to guess the number. The computer should tell the user if their guess is too high or too low. The user should be able to quit the game at any time. The user should be told how many guesses it took them to guess the number when they win. Example Welcome to the number guessing game! I am thinking of a number between 1 and 100. Guess the number: 50 Too high! Guess the number: 25 Too low! Guess the number: 37 Too high! Guess the number: 31 Too high! Guess the number: 28 Too low! Guess the number: 29 You win! It took you 6 guesses. Do you want to play again? (y/n): n Tips Use the io.inputln() function to read user input. Use the io.println() function to print output. String library contains parse() function that can be used to convert user input to a number. The generated number can be constant. Strategy This is a good time to start thinking about how you will structure your code. In my head I'm focusing on the following parts: - Ability to ask the user for input until they guess the correct number. - Changing the game answer based on the user's input. - Keeping track of how many guesses the user has made. - Telling the user how many guesses they made when they win. Solution NO CHEATING! Just kidding, but seriously try to solve the problem yourself before looking at the solution. import \"#io\" import \"#string\" fun main() { let answer = 29 let guesses = 0 io.println(\"Welcome to the number guessing game!\") io.println(\"I am thinking of a number between 1 and 100.\") loop { io.print(\"Guess the number: \") let guess = string.parse(io.inputln()) guesses += 1 if guess < answer { io.println(\"Too low!\") } else if guess > answer { io.println(\"Too high!\") } else { io.println(\"You win! It took you \" + guesses as string + \" guesses.\") break } } } Explanation Let's go over the solution. First we import the io and string libraries. import \"#io\" import \"#string\" Then we define the main() function. This is the entry point of our program. fun main() { // ... } Then we create a variable called guesses and assign it the value of 0 . This variable will be used to keep track of how many guesses the user has made. We also create a variable called answer and assign it the value of 29 . This variable will be used to store the answer to the game. ```ruda let guesses = 0 let answer = 29 After the initial setup, we print a welcome message and tell the user that we are thinking of a number between 1 and 100. io.println(\"Welcome to the number guessing game!\") io.println(\"I am thinking of a number between 1 and 100.\") Then we start a loop that will keep asking the user for input until they guess the correct number. loop { // ... } Inside the loop we ask the user to guess the number and read their input. We convert the user's input to a number using the string.parse() function. io.print(\"Guess the number: \") let guess = string.parse(io.inputln()) Then we increment the guesses variable by 1 to keep track of how many guesses the user has made. guesses += 1 Then we check if the user's guess is less than the answer. If it is, we tell the user that their guess is too low. if guess < answer { io.println(\"Too low!\") } If the user's guess is not less than the answer, we check if it is greater than the answer. If it is, we tell the user that their guess is too high. } else if guess > answer { io.println(\"Too high!\") } If the user's guess is not less than or greater than the answer, it must be equal to the answer. In this case we tell the user that they won and how many guesses it took them to guess the number. } else { io.println(\"You win! It took you \" + guesses as string + \" guesses.\") break } Finally we break out of the loop and the program ends.","title":"1. Number Guessing Game"},{"location":"projects/number-guessing-game/#number-guessing-game","text":"This is probably your first time writing a program in Ruda. Good luck!","title":"Number guessing game"},{"location":"projects/number-guessing-game/#what-are-we-building","text":"In this project you will create a number guessing game. The computer will think of a predefined number between 1 and 100 and you will try to guess it. The computer will tell you if your guess is too high or too low.","title":"What are we building?"},{"location":"projects/number-guessing-game/#requirements","text":"The user should be able to guess the number. The computer should tell the user if their guess is too high or too low. The user should be able to quit the game at any time. The user should be told how many guesses it took them to guess the number when they win.","title":"Requirements"},{"location":"projects/number-guessing-game/#example","text":"Welcome to the number guessing game! I am thinking of a number between 1 and 100. Guess the number: 50 Too high! Guess the number: 25 Too low! Guess the number: 37 Too high! Guess the number: 31 Too high! Guess the number: 28 Too low! Guess the number: 29 You win! It took you 6 guesses. Do you want to play again? (y/n): n","title":"Example"},{"location":"projects/number-guessing-game/#tips","text":"Use the io.inputln() function to read user input. Use the io.println() function to print output. String library contains parse() function that can be used to convert user input to a number. The generated number can be constant.","title":"Tips"},{"location":"projects/number-guessing-game/#strategy","text":"This is a good time to start thinking about how you will structure your code. In my head I'm focusing on the following parts: - Ability to ask the user for input until they guess the correct number. - Changing the game answer based on the user's input. - Keeping track of how many guesses the user has made. - Telling the user how many guesses they made when they win.","title":"Strategy"},{"location":"projects/number-guessing-game/#solution","text":"NO CHEATING! Just kidding, but seriously try to solve the problem yourself before looking at the solution. import \"#io\" import \"#string\" fun main() { let answer = 29 let guesses = 0 io.println(\"Welcome to the number guessing game!\") io.println(\"I am thinking of a number between 1 and 100.\") loop { io.print(\"Guess the number: \") let guess = string.parse(io.inputln()) guesses += 1 if guess < answer { io.println(\"Too low!\") } else if guess > answer { io.println(\"Too high!\") } else { io.println(\"You win! It took you \" + guesses as string + \" guesses.\") break } } }","title":"Solution"},{"location":"projects/number-guessing-game/#explanation","text":"Let's go over the solution. First we import the io and string libraries. import \"#io\" import \"#string\" Then we define the main() function. This is the entry point of our program. fun main() { // ... } Then we create a variable called guesses and assign it the value of 0 . This variable will be used to keep track of how many guesses the user has made. We also create a variable called answer and assign it the value of 29 . This variable will be used to store the answer to the game. ```ruda let guesses = 0 let answer = 29 After the initial setup, we print a welcome message and tell the user that we are thinking of a number between 1 and 100. io.println(\"Welcome to the number guessing game!\") io.println(\"I am thinking of a number between 1 and 100.\") Then we start a loop that will keep asking the user for input until they guess the correct number. loop { // ... } Inside the loop we ask the user to guess the number and read their input. We convert the user's input to a number using the string.parse() function. io.print(\"Guess the number: \") let guess = string.parse(io.inputln()) Then we increment the guesses variable by 1 to keep track of how many guesses the user has made. guesses += 1 Then we check if the user's guess is less than the answer. If it is, we tell the user that their guess is too low. if guess < answer { io.println(\"Too low!\") } If the user's guess is not less than the answer, we check if it is greater than the answer. If it is, we tell the user that their guess is too high. } else if guess > answer { io.println(\"Too high!\") } If the user's guess is not less than or greater than the answer, it must be equal to the answer. In this case we tell the user that they won and how many guesses it took them to guess the number. } else { io.println(\"You win! It took you \" + guesses as string + \" guesses.\") break } Finally we break out of the loop and the program ends.","title":"Explanation"},{"location":"tutorial/comments/","text":"Comments Comments are ignored by the compiler and are used to document the code. Single-line comments Single-line comments start with // and end at the end of the line. // This is a single-line comment Multi-line comments Multi-line comments start with /* and end with */ . /* This is a multi-line comment */ Why use comments? Comments are used to document the code. They are ignored by the compiler and are not executed. They are used to explain the code to other programmers. example: // This program prints \"Hello world\" to the console import \"std.io\" fun main() { io.println(\"Hello world\") } Compare this snippet from Hello world: import \"std.io\" fun main() { io.println(\"Hello world\") } They both do the same thing, but the commented one is much easier to understand.","title":"4. Comments"},{"location":"tutorial/comments/#comments","text":"Comments are ignored by the compiler and are used to document the code.","title":"Comments"},{"location":"tutorial/comments/#single-line-comments","text":"Single-line comments start with // and end at the end of the line. // This is a single-line comment","title":"Single-line comments"},{"location":"tutorial/comments/#multi-line-comments","text":"Multi-line comments start with /* and end with */ . /* This is a multi-line comment */","title":"Multi-line comments"},{"location":"tutorial/comments/#why-use-comments","text":"Comments are used to document the code. They are ignored by the compiler and are not executed. They are used to explain the code to other programmers. example: // This program prints \"Hello world\" to the console import \"std.io\" fun main() { io.println(\"Hello world\") } Compare this snippet from Hello world: import \"std.io\" fun main() { io.println(\"Hello world\") } They both do the same thing, but the commented one is much easier to understand.","title":"Why use comments?"},{"location":"tutorial/constants/","text":"Constants \u26a0\ufe0f Under development \u26a0\ufe0f: Constat values are a lot more complex than it may seem and require special care during development. This feature will be available in future versions. Constants are values that cannot be changed. They are declared using the const keyword. Unlike variables, constants must be assigned a value when they are declared. And they can be Accessed anywhere if imported. const PI = 3.14 This declares a constant named PI and assigns it the value 3.14 . Naming conventions Constants should be named using UPPER_SNAKE_CASE . const FAVORITE_NUMBER = 34 Why use constants? Constants are used to store values that will not change. They are useful for storing values that are used multiple times in the program. By using constants, you can also give names to values that would otherwise be hard to understand. When you see WINDOW_WIDTH in your code, you know that it is the width of the window. But if you see 800 , you have no idea what it means. Another advantage of constants is that modules can export them. This allows other modules to use them.","title":"7. Constants"},{"location":"tutorial/constants/#constants","text":"\u26a0\ufe0f Under development \u26a0\ufe0f: Constat values are a lot more complex than it may seem and require special care during development. This feature will be available in future versions. Constants are values that cannot be changed. They are declared using the const keyword. Unlike variables, constants must be assigned a value when they are declared. And they can be Accessed anywhere if imported. const PI = 3.14 This declares a constant named PI and assigns it the value 3.14 .","title":"Constants"},{"location":"tutorial/constants/#naming-conventions","text":"Constants should be named using UPPER_SNAKE_CASE . const FAVORITE_NUMBER = 34","title":"Naming conventions"},{"location":"tutorial/constants/#why-use-constants","text":"Constants are used to store values that will not change. They are useful for storing values that are used multiple times in the program. By using constants, you can also give names to values that would otherwise be hard to understand. When you see WINDOW_WIDTH in your code, you know that it is the width of the window. But if you see 800 , you have no idea what it means. Another advantage of constants is that modules can export them. This allows other modules to use them.","title":"Why use constants?"},{"location":"tutorial/control-flow/","text":"Control flow Control flow lets you control the order in which your code is executed. It allows you to add logic to your programs. Conditional statements Conditional statements are used to execute certain code only if a certain condition is met. if true { io.println(\"This will be printed\") } if false { io.println(\"This will not be printed\") } This will print This will be printed to the console. Else You can use the else keyword to execute code if the condition is not met. if false { io.println(\"This will not be printed\") } else { io.println(\"This will be printed\") } This will print This will be printed to the console. Else if You can use the else if keyword to execute code if the condition is not met and another condition is met. if false { io.println(\"This will not be printed\") } else if true { io.println(\"This will be printed\") } else { io.println(\"This will not be printed\") } This will print This will be printed to the console. After one of the conditions is met, the rest of the conditions are not checked. Switch statements \u26a0\ufe0f Unstable feature \u26a0\ufe0f Switch statements are used to execute different code depending on the value of a variable. let x = 5 switch x { 0 { io.println(\"x is 0\") }, 1 { io.println(\"x is 1\") }, 5 { io.println(\"x is 5\") }, _ { io.println(\"x is not 0, 1 or 5\") } } This will print x is 5 to the console. The _ case is the default case. It is executed if none of the other cases are executed. Loops Loops are used to execute code multiple times. Loop The loop keyword is used to create an infinite loop. loop { io.println(\"This will be printed forever\") } This will print This will be printed forever to the console forever. While The while keyword is used to create a loop that executes while a certain condition is met. let x = 0 while x < 5 { io.println(x) x += 1 } This will print 0 , 1 , 2 , 3 and 4 to the console. For \u26a0\ufe0f Unstable feature \u26a0\ufe0f The for keyword is used to create a loop that executes for each item in a collection. let numbers = [1, 2, 3, 4, 5] for number in numbers { io.println(number) } This will print 1 , 2 , 3 , 4 and 5 to the console. Break The break keyword is used to exit a loop. let x = 0 while true { io.println(x) x += 1 if x == 5 { break } } This will print 0 , 1 , 2 , 3 and 4 to the console. Continue The continue keyword is used to skip the rest of the loop and continue to the next iteration. let numbers = [1, 2, 3, 4, 5] for number in numbers { if number == 3 { continue } io.println(number) } This will print 1 , 2 , 4 and 5 to the console. Labels Breaking targets only the nearest loop: loop { loop { // <--- this will exit break } } // results in infinite loop To prevent this behaviour you can label your loops and later use the label to specify which loop you want to break. loop \"myLoop\": { break \"myLoop\" } while \"myWhile\": true { break \"myWhile\" } for \"myFor\": i in arr { break \"myFor\" } loop \"main\": { // <--- this will exit loop \"secondary\": { loop { break \"main\" } } io.println(\"You will never see this Mark!\") } Same can be applied to continues loop \"a\": { continue \"a\" } // infinite loop that ends on continue statement","title":"5. Control Flow"},{"location":"tutorial/control-flow/#control-flow","text":"Control flow lets you control the order in which your code is executed. It allows you to add logic to your programs.","title":"Control flow"},{"location":"tutorial/control-flow/#conditional-statements","text":"Conditional statements are used to execute certain code only if a certain condition is met. if true { io.println(\"This will be printed\") } if false { io.println(\"This will not be printed\") } This will print This will be printed to the console.","title":"Conditional statements"},{"location":"tutorial/control-flow/#else","text":"You can use the else keyword to execute code if the condition is not met. if false { io.println(\"This will not be printed\") } else { io.println(\"This will be printed\") } This will print This will be printed to the console.","title":"Else"},{"location":"tutorial/control-flow/#else-if","text":"You can use the else if keyword to execute code if the condition is not met and another condition is met. if false { io.println(\"This will not be printed\") } else if true { io.println(\"This will be printed\") } else { io.println(\"This will not be printed\") } This will print This will be printed to the console. After one of the conditions is met, the rest of the conditions are not checked.","title":"Else if"},{"location":"tutorial/control-flow/#switch-statements","text":"\u26a0\ufe0f Unstable feature \u26a0\ufe0f Switch statements are used to execute different code depending on the value of a variable. let x = 5 switch x { 0 { io.println(\"x is 0\") }, 1 { io.println(\"x is 1\") }, 5 { io.println(\"x is 5\") }, _ { io.println(\"x is not 0, 1 or 5\") } } This will print x is 5 to the console. The _ case is the default case. It is executed if none of the other cases are executed.","title":"Switch statements"},{"location":"tutorial/control-flow/#loops","text":"Loops are used to execute code multiple times.","title":"Loops"},{"location":"tutorial/control-flow/#loop","text":"The loop keyword is used to create an infinite loop. loop { io.println(\"This will be printed forever\") } This will print This will be printed forever to the console forever.","title":"Loop"},{"location":"tutorial/control-flow/#while","text":"The while keyword is used to create a loop that executes while a certain condition is met. let x = 0 while x < 5 { io.println(x) x += 1 } This will print 0 , 1 , 2 , 3 and 4 to the console.","title":"While"},{"location":"tutorial/control-flow/#for","text":"\u26a0\ufe0f Unstable feature \u26a0\ufe0f The for keyword is used to create a loop that executes for each item in a collection. let numbers = [1, 2, 3, 4, 5] for number in numbers { io.println(number) } This will print 1 , 2 , 3 , 4 and 5 to the console.","title":"For"},{"location":"tutorial/control-flow/#break","text":"The break keyword is used to exit a loop. let x = 0 while true { io.println(x) x += 1 if x == 5 { break } } This will print 0 , 1 , 2 , 3 and 4 to the console.","title":"Break"},{"location":"tutorial/control-flow/#continue","text":"The continue keyword is used to skip the rest of the loop and continue to the next iteration. let numbers = [1, 2, 3, 4, 5] for number in numbers { if number == 3 { continue } io.println(number) } This will print 1 , 2 , 4 and 5 to the console.","title":"Continue"},{"location":"tutorial/control-flow/#labels","text":"Breaking targets only the nearest loop: loop { loop { // <--- this will exit break } } // results in infinite loop To prevent this behaviour you can label your loops and later use the label to specify which loop you want to break. loop \"myLoop\": { break \"myLoop\" } while \"myWhile\": true { break \"myWhile\" } for \"myFor\": i in arr { break \"myFor\" } loop \"main\": { // <--- this will exit loop \"secondary\": { loop { break \"main\" } } io.println(\"You will never see this Mark!\") } Same can be applied to continues loop \"a\": { continue \"a\" } // infinite loop that ends on continue statement","title":"Labels"},{"location":"tutorial/data-types/","text":"Data Types Types describe the kind of data that is stored in a variable. Primitive Types Primitive types are the most basic data types. Type Description Example int Integer 1 & -1 float Floating point number 3.14 bool Boolean true & false string String \"Hello, World!\" char Character 'a' & '\\n' uint Unsigned Integer 0 Composite Types Composite types are types that are composed of other types. Type Description Example array Array let arr: [int] = [1, 2, 3] struct Struct struct Point { x: int, y: int } enum Enum enum Code { Ok = 200, NotFound = 404 } Pointers Pointers are used to store the address of a variable. let x: int = 1 let ptr: &int = &x Another type of pointer is a function pointer. Function pointers are used to store the address of a function. fun add(x: int, y: int): int { return x + y } let ptr = add This is useful for passing functions as arguments to other functions. Type Casting Type casting is used to convert a value from one type to another. let x: int = 1 let y = x as float Type Aliases Type aliases help abstract away the implementation details of a type. type FileHandle = uint Optionals Optionals are used to represent values that may or may not exist. let x: int? = 1 // x == 1 let y: int? // y == null Then we can use the ? operator to see if the value exists. let x: int? = 1 if x? { // x exists } else { // x does not exist }","title":"8. Data Types"},{"location":"tutorial/data-types/#data-types","text":"Types describe the kind of data that is stored in a variable.","title":"Data Types"},{"location":"tutorial/data-types/#primitive-types","text":"Primitive types are the most basic data types. Type Description Example int Integer 1 & -1 float Floating point number 3.14 bool Boolean true & false string String \"Hello, World!\" char Character 'a' & '\\n' uint Unsigned Integer 0","title":"Primitive Types"},{"location":"tutorial/data-types/#composite-types","text":"Composite types are types that are composed of other types. Type Description Example array Array let arr: [int] = [1, 2, 3] struct Struct struct Point { x: int, y: int } enum Enum enum Code { Ok = 200, NotFound = 404 }","title":"Composite Types"},{"location":"tutorial/data-types/#pointers","text":"Pointers are used to store the address of a variable. let x: int = 1 let ptr: &int = &x Another type of pointer is a function pointer. Function pointers are used to store the address of a function. fun add(x: int, y: int): int { return x + y } let ptr = add This is useful for passing functions as arguments to other functions.","title":"Pointers"},{"location":"tutorial/data-types/#type-casting","text":"Type casting is used to convert a value from one type to another. let x: int = 1 let y = x as float","title":"Type Casting"},{"location":"tutorial/data-types/#type-aliases","text":"Type aliases help abstract away the implementation details of a type. type FileHandle = uint","title":"Type Aliases"},{"location":"tutorial/data-types/#optionals","text":"Optionals are used to represent values that may or may not exist. let x: int? = 1 // x == 1 let y: int? // y == null Then we can use the ? operator to see if the value exists. let x: int? = 1 if x? { // x exists } else { // x does not exist }","title":"Optionals"},{"location":"tutorial/enums/","text":"Enums Enums in Ruda are quite boring. They are used for defining a type that can have a finite number of numbers. enum Color { Red, Green, Blue } You can also assign numbers to enum variants. enum Color { Red, // 0 Green = 5, // 5 Blue // 6 } Variant Matching There is no \"ergonomic\" way of matchng enums in the current version. To match two enums you need to cast one to any number and compare them. enum Color { Red, Green, Blue } fun main() { let myColor = Color.Red if myColor as int == Color.Red { io.println(\"The value is indeed red\") } else { io.println(\"The value does not seem to be red\") } }","title":"10. Enums"},{"location":"tutorial/enums/#enums","text":"Enums in Ruda are quite boring. They are used for defining a type that can have a finite number of numbers. enum Color { Red, Green, Blue } You can also assign numbers to enum variants. enum Color { Red, // 0 Green = 5, // 5 Blue // 6 }","title":"Enums"},{"location":"tutorial/enums/#variant-matching","text":"There is no \"ergonomic\" way of matchng enums in the current version. To match two enums you need to cast one to any number and compare them. enum Color { Red, Green, Blue } fun main() { let myColor = Color.Red if myColor as int == Color.Red { io.println(\"The value is indeed red\") } else { io.println(\"The value does not seem to be red\") } }","title":"Variant Matching"},{"location":"tutorial/error-handling/","text":"Error handling \u26a0\ufe0f Not implemented \u26a0\ufe0f: This feature is planned for the next update. Sometimes an operation can fail. For example, if you try to open a file that doesn't exist, or if you try to divide by zero. In Ruda, you can handle these errors using the try keyword. try { let file = io.open(\"file.txt\") } catch err { io.println(err) } The try keyword is used to call a function that can fail. If the function fails, the catch block is executed. The catch block is used to handle the error. The catch block takes a variable that stores the error. Catch statements You can have multiple catch statements to handle different errors. try { let file = io.open(\"file.txt\") } catch err: io.FileNotFound { io.println(err.msg()) } catch err { io.println(err.msg()) } Yeet The yeet keyword is used to throw an error. fun divide(x: int, y: int)!: int { if y == 0 { yeet Error(\"cannot divide by zero\") } return x / y } Error If you dont need to throw an error but you don't care about the error type, you can use the Error type as shown above. Bang operator If we don't want to handle the error, we can use the bang operator to ignore the error. It will be forwarded to the caller. fun divide(x: int, y: int)!: int { if y == 0 { yeet Error(\"cannot divide by zero\") } return x / y } fun main() { let result = divide(10, 0)! // this will crash } Error declaration You can declare an error type using the error keyword. error DivisionByZeroError(number: int) { message: \"cannot divide by zero\", code: 1, } This can be used like this: fun divide(x: int, y: int)!: int { if y == 0 { yeet DivisionByZeroError(y) } return x / y } The error field code is optional. It can be used to identify the error. Default value is 1. You can also take message as an argument. error Error(message: string?) { message: { if message? { return message } else { return \"something went wrong\" } } code: 1, }","title":"14. Error Handling"},{"location":"tutorial/error-handling/#error-handling","text":"\u26a0\ufe0f Not implemented \u26a0\ufe0f: This feature is planned for the next update. Sometimes an operation can fail. For example, if you try to open a file that doesn't exist, or if you try to divide by zero. In Ruda, you can handle these errors using the try keyword. try { let file = io.open(\"file.txt\") } catch err { io.println(err) } The try keyword is used to call a function that can fail. If the function fails, the catch block is executed. The catch block is used to handle the error. The catch block takes a variable that stores the error.","title":"Error handling"},{"location":"tutorial/error-handling/#catch-statements","text":"You can have multiple catch statements to handle different errors. try { let file = io.open(\"file.txt\") } catch err: io.FileNotFound { io.println(err.msg()) } catch err { io.println(err.msg()) }","title":"Catch statements"},{"location":"tutorial/error-handling/#yeet","text":"The yeet keyword is used to throw an error. fun divide(x: int, y: int)!: int { if y == 0 { yeet Error(\"cannot divide by zero\") } return x / y }","title":"Yeet"},{"location":"tutorial/error-handling/#error","text":"If you dont need to throw an error but you don't care about the error type, you can use the Error type as shown above.","title":"Error"},{"location":"tutorial/error-handling/#bang-operator","text":"If we don't want to handle the error, we can use the bang operator to ignore the error. It will be forwarded to the caller. fun divide(x: int, y: int)!: int { if y == 0 { yeet Error(\"cannot divide by zero\") } return x / y } fun main() { let result = divide(10, 0)! // this will crash }","title":"Bang operator"},{"location":"tutorial/error-handling/#error-declaration","text":"You can declare an error type using the error keyword. error DivisionByZeroError(number: int) { message: \"cannot divide by zero\", code: 1, } This can be used like this: fun divide(x: int, y: int)!: int { if y == 0 { yeet DivisionByZeroError(y) } return x / y } The error field code is optional. It can be used to identify the error. Default value is 1. You can also take message as an argument. error Error(message: string?) { message: { if message? { return message } else { return \"something went wrong\" } } code: 1, }","title":"Error declaration"},{"location":"tutorial/functions/","text":"Functions Functions are useful for writing code that you want to reuse. They can be defined anywhere in the file, and can be called anywhere in the file. You already know how to use functions, because main is a function. Defining a function To define a function, use the fun keyword. The body of the function is enclosed in curly braces. fun greet() { io.println(\"Hello world\") } This defines a function called greet . Now we can call the function. import \"#io\" fun greet() { io.println(\"Hello world\") } fun main() { greet() greet() // We can call the function multiple times greet() greet() } This will print Hello world to the console 4 times. Parameters Functions can take parameters. Parameters are variables that are passed to the function when it is called. They are used to pass data to the function. fun greet(name: string) { io.println(\"Hello \" + name) } fun main() { greet(\"Terry\") } This will print Hello Terry to the console. Parameters need to have a type. Return values Functions can return values. Return values are used to pass data from the function to the caller. fun add(a: int, b: int): int { return a + b } fun main() { let result = add(5, 10) io.println(result) } This will print 15 to the console. Functions can only return one value which can be of any type. Anonymous functions \u26a0\ufe0f Planned for the next update \u26a0\ufe0f Functions can be defined without a name. These are called anonymous functions. import \"std.io\" fun main() { let greet = fun(name: string) { io.println(\"Hello \" + name) } greet(\"Terry\") } The type of greet is fun(string) . You can write the same thing like this let greet: fun(string) = fun(name: string) { ... } .","title":"6. Functions"},{"location":"tutorial/functions/#functions","text":"Functions are useful for writing code that you want to reuse. They can be defined anywhere in the file, and can be called anywhere in the file. You already know how to use functions, because main is a function.","title":"Functions"},{"location":"tutorial/functions/#defining-a-function","text":"To define a function, use the fun keyword. The body of the function is enclosed in curly braces. fun greet() { io.println(\"Hello world\") } This defines a function called greet . Now we can call the function. import \"#io\" fun greet() { io.println(\"Hello world\") } fun main() { greet() greet() // We can call the function multiple times greet() greet() } This will print Hello world to the console 4 times.","title":"Defining a function"},{"location":"tutorial/functions/#parameters","text":"Functions can take parameters. Parameters are variables that are passed to the function when it is called. They are used to pass data to the function. fun greet(name: string) { io.println(\"Hello \" + name) } fun main() { greet(\"Terry\") } This will print Hello Terry to the console. Parameters need to have a type.","title":"Parameters"},{"location":"tutorial/functions/#return-values","text":"Functions can return values. Return values are used to pass data from the function to the caller. fun add(a: int, b: int): int { return a + b } fun main() { let result = add(5, 10) io.println(result) } This will print 15 to the console. Functions can only return one value which can be of any type.","title":"Return values"},{"location":"tutorial/functions/#anonymous-functions","text":"\u26a0\ufe0f Planned for the next update \u26a0\ufe0f Functions can be defined without a name. These are called anonymous functions. import \"std.io\" fun main() { let greet = fun(name: string) { io.println(\"Hello \" + name) } greet(\"Terry\") } The type of greet is fun(string) . You can write the same thing like this let greet: fun(string) = fun(name: string) { ... } .","title":"Anonymous functions"},{"location":"tutorial/hello/","text":"Hello world Where else to start than with the classic \"Hello world\" example. Before we start, make sure you have the Ruda virtual machine installed. You can find instructions on how to do that here . When you create a new project, Ruda will automatically create a main.rd file in the src directory. This is where you will write your code. Open the main.rd file. You should see the following code: import \"#io\" fun main() { io.println(\"Hello world\") } Let's go through this line by line. import \"#io\" This line imports the io module from the standard library. This module allows you to read and write to the console. fun main() { This line defines a function called main . This is the entry point of the program. The program will start executing from here. io.println(\"Hello world\") This line calls the println function from the io module. This function prints the given string to the console. } This line ends the main function. Running the program To run the program, run the following command: ruda run This will build and run the program. If you did everything correctly, you should see the following output: Hello world Congratulations! You have successfully written and run your first Ruda program.","title":"1. Hello World"},{"location":"tutorial/hello/#hello-world","text":"Where else to start than with the classic \"Hello world\" example. Before we start, make sure you have the Ruda virtual machine installed. You can find instructions on how to do that here . When you create a new project, Ruda will automatically create a main.rd file in the src directory. This is where you will write your code. Open the main.rd file. You should see the following code: import \"#io\" fun main() { io.println(\"Hello world\") } Let's go through this line by line. import \"#io\" This line imports the io module from the standard library. This module allows you to read and write to the console. fun main() { This line defines a function called main . This is the entry point of the program. The program will start executing from here. io.println(\"Hello world\") This line calls the println function from the io module. This function prints the given string to the console. } This line ends the main function.","title":"Hello world"},{"location":"tutorial/hello/#running-the-program","text":"To run the program, run the following command: ruda run This will build and run the program. If you did everything correctly, you should see the following output: Hello world Congratulations! You have successfully written and run your first Ruda program.","title":"Running the program"},{"location":"tutorial/methods/","text":"Methods Methods are functions that are defined on a type. Thats all there is to it. Defining methods Methods are defined after the struct fields. If the struct contains constructor, it must be the first method defined. struct Order { // fields are always first field1: int field2: float // .. // constructor follows new (n: int) { self.field1 = n self.field2 = 60f } // the rest of the methods fun set1(self, n: int){ self.field1 = n } // .. } struct Person { name: string age: int new (name: string, age: int) { self.name = name self.age = age } fun greet(self) { io.println(\"Hello, my name is \" + self.name) } } Here we first define a struct named Person with two fields name and age . Then we define a constructor for the Person struct, this is the same constructor we defined in the Structs section. Then we define a method named greet that prints a greeting message. The method takes a self parameter. This is a special parameter that refers to the struct instance. We use self to access the struct fields. Calling methods Methods are called using the dot operator. let person = Person(\"Terry\", 34) person.greet() // Hello, my name is Terry Self Self is a special variable that refers to the struct instance. We use self to access the struct fields. Static methods Static methods are methods that are defined on the type itself. They are called using the type name. struct Person { name: string age: int new (name: string, age: int) { self.name = name self.age = age } fun greet(self) { io.println(\"Hello, my name is \" + self.name) } fun create(name: string, age: int): Person { return Person(name, age) } } let person = Person.create(\"Terry\", 34) Here we define a static method named create that creates a new Person struct. Static vs Instance methods Static methods are called using the type name while instance methods are called using the struct instance. Static methods are useful for creating alternative constructors.","title":"12. Methods"},{"location":"tutorial/methods/#methods","text":"Methods are functions that are defined on a type. Thats all there is to it.","title":"Methods"},{"location":"tutorial/methods/#defining-methods","text":"Methods are defined after the struct fields. If the struct contains constructor, it must be the first method defined. struct Order { // fields are always first field1: int field2: float // .. // constructor follows new (n: int) { self.field1 = n self.field2 = 60f } // the rest of the methods fun set1(self, n: int){ self.field1 = n } // .. } struct Person { name: string age: int new (name: string, age: int) { self.name = name self.age = age } fun greet(self) { io.println(\"Hello, my name is \" + self.name) } } Here we first define a struct named Person with two fields name and age . Then we define a constructor for the Person struct, this is the same constructor we defined in the Structs section. Then we define a method named greet that prints a greeting message. The method takes a self parameter. This is a special parameter that refers to the struct instance. We use self to access the struct fields.","title":"Defining methods"},{"location":"tutorial/methods/#calling-methods","text":"Methods are called using the dot operator. let person = Person(\"Terry\", 34) person.greet() // Hello, my name is Terry","title":"Calling methods"},{"location":"tutorial/methods/#self","text":"Self is a special variable that refers to the struct instance. We use self to access the struct fields.","title":"Self"},{"location":"tutorial/methods/#static-methods","text":"Static methods are methods that are defined on the type itself. They are called using the type name. struct Person { name: string age: int new (name: string, age: int) { self.name = name self.age = age } fun greet(self) { io.println(\"Hello, my name is \" + self.name) } fun create(name: string, age: int): Person { return Person(name, age) } } let person = Person.create(\"Terry\", 34) Here we define a static method named create that creates a new Person struct.","title":"Static methods"},{"location":"tutorial/methods/#static-vs-instance-methods","text":"Static methods are called using the type name while instance methods are called using the struct instance. Static methods are useful for creating alternative constructors.","title":"Static vs Instance methods"},{"location":"tutorial/modules/","text":"Modules This will be a short tutorial on how modularity works in Ruda. What is a module? A module is a file that contains code. Modules can be imported into other modules. This allows you to use the code from one module in another module. Creating a module To create a module, you need to create a file with the .rd extension. This is the extension used for Ruda modules. Example: // file: math.rd fun add(x: int, y: int): int { return x + y } const PI = 3.14 This creates a module named math that contains a function named add and a constant named PI . Importing a module To import a module, you need to use the import keyword, followed by the name of the module. Example: import \"math.rd\" fun main() { let result = math.add(1, 2) io.println(result) // 3 } This imports the math module and uses the add function from it. Aliasing a module You can also alias a module using the as keyword. Example: import \"math.rd\" as m fun main() { let result = m.add(1, 2) io.println(result) // 3 }","title":"13. Modules"},{"location":"tutorial/modules/#modules","text":"This will be a short tutorial on how modularity works in Ruda.","title":"Modules"},{"location":"tutorial/modules/#what-is-a-module","text":"A module is a file that contains code. Modules can be imported into other modules. This allows you to use the code from one module in another module.","title":"What is a module?"},{"location":"tutorial/modules/#creating-a-module","text":"To create a module, you need to create a file with the .rd extension. This is the extension used for Ruda modules. Example: // file: math.rd fun add(x: int, y: int): int { return x + y } const PI = 3.14 This creates a module named math that contains a function named add and a constant named PI .","title":"Creating a module"},{"location":"tutorial/modules/#importing-a-module","text":"To import a module, you need to use the import keyword, followed by the name of the module. Example: import \"math.rd\" fun main() { let result = math.add(1, 2) io.println(result) // 3 } This imports the math module and uses the add function from it.","title":"Importing a module"},{"location":"tutorial/modules/#aliasing-a-module","text":"You can also alias a module using the as keyword. Example: import \"math.rd\" as m fun main() { let result = m.add(1, 2) io.println(result) // 3 }","title":"Aliasing a module"},{"location":"tutorial/new-project/","text":"New Project Create a new project To create a new project, run the following command: ruda init hello This will create a new directory called hello containing the following files: src/ main.rd Ruda.toml .gitignore Running the project First make sure you are in the project directory: cd hello Then run the following command: ruda run This will build and run the project. You should see the following output: Hello, world!","title":"0. New Project"},{"location":"tutorial/new-project/#new-project","text":"","title":"New Project"},{"location":"tutorial/new-project/#create-a-new-project","text":"To create a new project, run the following command: ruda init hello This will create a new directory called hello containing the following files: src/ main.rd Ruda.toml .gitignore","title":"Create a new project"},{"location":"tutorial/new-project/#running-the-project","text":"First make sure you are in the project directory: cd hello Then run the following command: ruda run This will build and run the project. You should see the following output: Hello, world!","title":"Running the project"},{"location":"tutorial/operators/","text":"Operators This page contains a list of all operators in Ruda. If you are new to programming, you can skip this page for now and return when you need to learn about a specific operator. Arithmetic Operators Sometimes you need to perform arithmetic operations on variables. For example, you may need to increment or decrement a variable's value. Operator Description Example + Addition x + y - Subtraction x - y * Multiplication x * y / Division x / y % Modulus x % y example: let x = 5 let y = 10 let sum = x + y let difference = x - y // ... and so on Assignment Operators Assignment operators are used to assign values to variables. Operator Description Example = Assign x = y += Add and assign x += y -= Subtract and assign x -= y *= Multiply and assign x *= y /= Divide and assign x /= y example: let x = 5 let y = 10 x += y // the same as: x = x + y // ... and so on Comparison Operators Comparison operators are used to compare values. Operator Description Example == Equal x == y != Not equal x != y < Less than x < y > Greater than x > y <= Less than or equal x <= y >= Greater than or equal x >= y example: let x = 5 let y = 10 let equal = x == y // false // ... and so on Logical Operators Logical operators are used to combine boolean expressions. Operator Description Example && Logical AND x && y || Logical OR x || y ! Logical NOT !x Error handling operators Error handling operators are used to handle errors. Operator Description Example ? Exists? x? returns true if x is not null ! Trust me x()! forwards the error if x threw an error","title":"3. Operators"},{"location":"tutorial/operators/#operators","text":"This page contains a list of all operators in Ruda. If you are new to programming, you can skip this page for now and return when you need to learn about a specific operator.","title":"Operators"},{"location":"tutorial/operators/#arithmetic-operators","text":"Sometimes you need to perform arithmetic operations on variables. For example, you may need to increment or decrement a variable's value. Operator Description Example + Addition x + y - Subtraction x - y * Multiplication x * y / Division x / y % Modulus x % y example: let x = 5 let y = 10 let sum = x + y let difference = x - y // ... and so on","title":"Arithmetic Operators"},{"location":"tutorial/operators/#assignment-operators","text":"Assignment operators are used to assign values to variables. Operator Description Example = Assign x = y += Add and assign x += y -= Subtract and assign x -= y *= Multiply and assign x *= y /= Divide and assign x /= y example: let x = 5 let y = 10 x += y // the same as: x = x + y // ... and so on","title":"Assignment Operators"},{"location":"tutorial/operators/#comparison-operators","text":"Comparison operators are used to compare values. Operator Description Example == Equal x == y != Not equal x != y < Less than x < y > Greater than x > y <= Less than or equal x <= y >= Greater than or equal x >= y example: let x = 5 let y = 10 let equal = x == y // false // ... and so on","title":"Comparison Operators"},{"location":"tutorial/operators/#logical-operators","text":"Logical operators are used to combine boolean expressions. Operator Description Example && Logical AND x && y || Logical OR x || y ! Logical NOT !x","title":"Logical Operators"},{"location":"tutorial/operators/#error-handling-operators","text":"Error handling operators are used to handle errors. Operator Description Example ? Exists? x? returns true if x is not null ! Trust me x()! forwards the error if x threw an error","title":"Error handling operators"},{"location":"tutorial/pointers/","text":"Pointers We have already seen pointers in the Data types section. In this section we will learn more about pointers. What is a pointer? A pointer is a variable that stores the address of another variable. In other words, a pointer points to another variable. Creating a pointer Pointers are created using the & operator. let x: int = 1 let ptr = &x This creates a pointer named ptr that points to the variable x . When we print the value of ptr , we get the address of x . io.println(ptr) // a big number Dereferencing a pointer Dereferencing a pointer means accessing the value stored at the address pointed to by the pointer. let x: int = 1 let ptr = &x io.println(*ptr) // 1 The * operator is used to dereference a pointer. Pointers to pointers Pointers can also point to other pointers. let x: int = 1 let ptr1 = &x let ptr2 = &ptr1 io.println(*ptr2) // a big number io.println(**ptr2) // 1 Why use pointers? Pointers are useful for passing variables by reference. This means that the function can modify the variable passed to it. fun addOne(x: &int) { *x = *x + 1 } let x: int = 1 addOne(&x) io.println(x) // 2","title":"11. Pointers"},{"location":"tutorial/pointers/#pointers","text":"We have already seen pointers in the Data types section. In this section we will learn more about pointers.","title":"Pointers"},{"location":"tutorial/pointers/#what-is-a-pointer","text":"A pointer is a variable that stores the address of another variable. In other words, a pointer points to another variable.","title":"What is a pointer?"},{"location":"tutorial/pointers/#creating-a-pointer","text":"Pointers are created using the & operator. let x: int = 1 let ptr = &x This creates a pointer named ptr that points to the variable x . When we print the value of ptr , we get the address of x . io.println(ptr) // a big number","title":"Creating a pointer"},{"location":"tutorial/pointers/#dereferencing-a-pointer","text":"Dereferencing a pointer means accessing the value stored at the address pointed to by the pointer. let x: int = 1 let ptr = &x io.println(*ptr) // 1 The * operator is used to dereference a pointer.","title":"Dereferencing a pointer"},{"location":"tutorial/pointers/#pointers-to-pointers","text":"Pointers can also point to other pointers. let x: int = 1 let ptr1 = &x let ptr2 = &ptr1 io.println(*ptr2) // a big number io.println(**ptr2) // 1","title":"Pointers to pointers"},{"location":"tutorial/pointers/#why-use-pointers","text":"Pointers are useful for passing variables by reference. This means that the function can modify the variable passed to it. fun addOne(x: &int) { *x = *x + 1 } let x: int = 1 addOne(&x) io.println(x) // 2","title":"Why use pointers?"},{"location":"tutorial/structs/","text":"Structs As you may have noticed, we already saw a struct in the previous section. A struct is a collection of named values. Structs are useful for grouping related data together. Structs are declared using the struct keyword. struct Person { name: string age: int } This declares a struct named Person with two fields: name and age . Creating structs Structs can be created using their constructor. The constructor is the struct name followed by parentheses. let person = Person(\"Terry\", 34) Constructor The code above won't work because we haven't defined a constructor for the Person struct because Ruda couldn't generate a constructor for the struct because it has a field of type string . We can define a constructor for the Person struct like this: struct Person { name: string age: int new (name: string, age: int) { self.name = name self.age = age } } For now just know that constructor is a function that is called when a struct is created. The constructor is used to initialize the struct fields (name, age). Self is a special variable that refers to the struct instance. We use self to access the struct fields. Now we can create as many Person structs as we want. let person1 = Person(\"Terry\", 34) let person2 = Person(\"Danda\", 19) Accessing fields Struct fields can be accessed using the dot operator. let person = Person(\"Terry\", 34) io.println(person.name) // Terry io.println(person.age) // 34 Updating fields Struct fields can be updated using the dot operator. let person = Person(\"Terry\", 34) person.name = \"Danda\" person.age = 19 io.println(person.name) // Danda io.println(person.age) // 19","title":"9. Structs"},{"location":"tutorial/structs/#structs","text":"As you may have noticed, we already saw a struct in the previous section. A struct is a collection of named values. Structs are useful for grouping related data together. Structs are declared using the struct keyword. struct Person { name: string age: int } This declares a struct named Person with two fields: name and age .","title":"Structs"},{"location":"tutorial/structs/#creating-structs","text":"Structs can be created using their constructor. The constructor is the struct name followed by parentheses. let person = Person(\"Terry\", 34)","title":"Creating structs"},{"location":"tutorial/structs/#constructor","text":"The code above won't work because we haven't defined a constructor for the Person struct because Ruda couldn't generate a constructor for the struct because it has a field of type string . We can define a constructor for the Person struct like this: struct Person { name: string age: int new (name: string, age: int) { self.name = name self.age = age } } For now just know that constructor is a function that is called when a struct is created. The constructor is used to initialize the struct fields (name, age). Self is a special variable that refers to the struct instance. We use self to access the struct fields. Now we can create as many Person structs as we want. let person1 = Person(\"Terry\", 34) let person2 = Person(\"Danda\", 19)","title":"Constructor"},{"location":"tutorial/structs/#accessing-fields","text":"Struct fields can be accessed using the dot operator. let person = Person(\"Terry\", 34) io.println(person.name) // Terry io.println(person.age) // 34","title":"Accessing fields"},{"location":"tutorial/structs/#updating-fields","text":"Struct fields can be updated using the dot operator. let person = Person(\"Terry\", 34) person.name = \"Danda\" person.age = 19 io.println(person.name) // Danda io.println(person.age) // 19","title":"Updating fields"},{"location":"tutorial/variables/","text":"Variables Variables are used to store values. Those values can be used or modified later in the program. Variables can be declared using the let keyword. let x = 5 This declares a variable named x and assigns it the value 5 . To declare a variable without assigning it a value, you can use the let keyword without an expression. let x This declares a variable named x without assigning it a value. Variables can be assigned a new value using the = operator. let x = 5 x = 10 Knowing this, we can rewrite our hello world program to use a variable. import \"#io\" fun main() { let message = \"Hello world\" io.println(message) } This program will print Hello world to the console.","title":"2. Variables"},{"location":"tutorial/variables/#variables","text":"Variables are used to store values. Those values can be used or modified later in the program. Variables can be declared using the let keyword. let x = 5 This declares a variable named x and assigns it the value 5 . To declare a variable without assigning it a value, you can use the let keyword without an expression. let x This declares a variable named x without assigning it a value. Variables can be assigned a new value using the = operator. let x = 5 x = 10 Knowing this, we can rewrite our hello world program to use a variable. import \"#io\" fun main() { let message = \"Hello world\" io.println(message) } This program will print Hello world to the console.","title":"Variables"},{"location":"tutorial/advanced/generics/","text":"Generics \u26a0\ufe0f Experimental feature \u26a0\ufe0f: While simple examples work this is still in early development and more useful use cases are not supported yet. It is not recommended to use this. Generics are a feature that allows you to write code that can be reused for different types. For example, you might want to write a function that returns the first element of any array. This is a generic function because it can be used for any type of array, like an array of strings or an array of numbers. fun first<T>(array: [T]): T { return array[0] } fun main() { let array = [\"hello\", \"world\"] let first = first(array) } In this example, the first function is generic because it can be used for any type of array. The T in the function signature is a type parameter. It can be replaced with any type when the function is called. Syntax Generics are enclosed in angle brackets ( < and > ). The type parameters are separated by commas ( , ) and each type parameter can have a constraint . fun foo<T, U>(x: T, y: U): T { return x } struct Bar<T, U> { x: T, y: U, } trait Baz<T, U> { fun foo(x: T, y: U): T } Constraints Type parameters can have constraints. A constraint is a type that the type parameter must be a subtype of. For example, if we want to write a function that takes two numbers and returns the larger one, we can use the Comparable trait as a constraint. fun max<T(Comparable)>(x: T, y: T): T { if x > y { return x } else { return y } } In this example, the T type parameter must be a subtype of the Comparable trait. This means that the T type parameter must implement the Comparable trait. Note: The Comparable trait allows you to compare two values using the < , > , <= , and >= operators. Those types must be the same. This means that you can't compare T (Comparable) with U (Comparable) . T and U are not guaranteed to be the same type.","title":"1. Generics"},{"location":"tutorial/advanced/generics/#generics","text":"\u26a0\ufe0f Experimental feature \u26a0\ufe0f: While simple examples work this is still in early development and more useful use cases are not supported yet. It is not recommended to use this. Generics are a feature that allows you to write code that can be reused for different types. For example, you might want to write a function that returns the first element of any array. This is a generic function because it can be used for any type of array, like an array of strings or an array of numbers. fun first<T>(array: [T]): T { return array[0] } fun main() { let array = [\"hello\", \"world\"] let first = first(array) } In this example, the first function is generic because it can be used for any type of array. The T in the function signature is a type parameter. It can be replaced with any type when the function is called.","title":"Generics"},{"location":"tutorial/advanced/generics/#syntax","text":"Generics are enclosed in angle brackets ( < and > ). The type parameters are separated by commas ( , ) and each type parameter can have a constraint . fun foo<T, U>(x: T, y: U): T { return x } struct Bar<T, U> { x: T, y: U, } trait Baz<T, U> { fun foo(x: T, y: U): T }","title":"Syntax"},{"location":"tutorial/advanced/generics/#constraints","text":"Type parameters can have constraints. A constraint is a type that the type parameter must be a subtype of. For example, if we want to write a function that takes two numbers and returns the larger one, we can use the Comparable trait as a constraint. fun max<T(Comparable)>(x: T, y: T): T { if x > y { return x } else { return y } } In this example, the T type parameter must be a subtype of the Comparable trait. This means that the T type parameter must implement the Comparable trait. Note: The Comparable trait allows you to compare two values using the < , > , <= , and >= operators. Those types must be the same. This means that you can't compare T (Comparable) with U (Comparable) . T and U are not guaranteed to be the same type.","title":"Constraints"},{"location":"tutorial/advanced/hi/","text":"Hi If you are still figuring out how all the programming stuff works, then this is a great time to take a deep breath and relax. You have come a long way and you deserve a break. The best way to learn is to build something. I have prepared a beginner friendly project that you can try out here when you are ready. What's next? In the next section we will learn about Advanced topics in Ruda. You will learn everything there is to know about writing Ruda programs.","title":"0. Hello"},{"location":"tutorial/advanced/hi/#hi","text":"If you are still figuring out how all the programming stuff works, then this is a great time to take a deep breath and relax. You have come a long way and you deserve a break. The best way to learn is to build something. I have prepared a beginner friendly project that you can try out here when you are ready.","title":"Hi"},{"location":"tutorial/advanced/hi/#whats-next","text":"In the next section we will learn about Advanced topics in Ruda. You will learn everything there is to know about writing Ruda programs.","title":"What's next?"},{"location":"tutorial/advanced/memory/","text":"Memory Management Ruda uses a garbage collector to manage memory. This means that you don't have to worry about freeing memory yourself. However, this does not mean that you can't manage memory yourself. Ruda provides a way to allocate and free memory manually. Allocating memory You can allocate memory using the new keyword. This allocates memory on the heap and returns a pointer to the allocated memory. let x = new 5 Heap can be allocated for any type, including structs, enums, and arrays. struct Foo { x: int, } impl Foo { fun Foo(x: int) { self.x = x } } let foo = new Foo(5) Freeing memory Freeing memory will be part of the standard library in the future. For now, you just need to rely on the garbage collector (not that it doesn't do a good job). Working with Garbage collector Many languages implement GC to ensure memory safety and ease the development cycle. While all this is also true for Ruda, it takes a slightly different approach. Garbage collector manages memory, but the user manages the garbage collector. It is as easy as calling a method through the memory API in standard library. import \"#memory\" fun main(){ memory.Gc.sweep() } You right now: \" WHY? This has to be a step bacwards.. \" You may be right. The difference between good and bad GC is that you do not even notice the good one, therefore my implementation would be the worst possible. In the real world things are not so simple for anyone to decide whats the best memory model. Each has their uses. My offers ease of use combined with controll. In garbage collected languages you often dont know when the collector starts sweeping. This results in uncontrollable and unwanted lag spikes. Ruda offers more direct memory access while also hiding it when necessary.","title":"4. Memory Management"},{"location":"tutorial/advanced/memory/#memory-management","text":"Ruda uses a garbage collector to manage memory. This means that you don't have to worry about freeing memory yourself. However, this does not mean that you can't manage memory yourself. Ruda provides a way to allocate and free memory manually.","title":"Memory Management"},{"location":"tutorial/advanced/memory/#allocating-memory","text":"You can allocate memory using the new keyword. This allocates memory on the heap and returns a pointer to the allocated memory. let x = new 5 Heap can be allocated for any type, including structs, enums, and arrays. struct Foo { x: int, } impl Foo { fun Foo(x: int) { self.x = x } } let foo = new Foo(5)","title":"Allocating memory"},{"location":"tutorial/advanced/memory/#freeing-memory","text":"Freeing memory will be part of the standard library in the future. For now, you just need to rely on the garbage collector (not that it doesn't do a good job).","title":"Freeing memory"},{"location":"tutorial/advanced/memory/#working-with-garbage-collector","text":"Many languages implement GC to ensure memory safety and ease the development cycle. While all this is also true for Ruda, it takes a slightly different approach. Garbage collector manages memory, but the user manages the garbage collector. It is as easy as calling a method through the memory API in standard library. import \"#memory\" fun main(){ memory.Gc.sweep() } You right now: \" WHY? This has to be a step bacwards.. \" You may be right. The difference between good and bad GC is that you do not even notice the good one, therefore my implementation would be the worst possible. In the real world things are not so simple for anyone to decide whats the best memory model. Each has their uses. My offers ease of use combined with controll. In garbage collected languages you often dont know when the collector starts sweeping. This results in uncontrollable and unwanted lag spikes. Ruda offers more direct memory access while also hiding it when necessary.","title":"Working with Garbage collector"},{"location":"tutorial/advanced/overloads/","text":"Operator Overloading \u26a0\ufe0f This feature is unlikely to ever be implemented \u26a0\ufe0f: Source code should work the way you expect it to. Operator overloads may cause a lot of confusion. TLDR: bad This is a feature that allows you to define the behavior of operators when applied to your own types. For example, you can define what happens when you add two instances of your class together, or when you compare them for equality. Syntax Operator overloading is done inside the impl block of a type. The operator is defined using the operator keyword. struct Foo { x: int, } impl Foo { operator + (other: Foo): Foo { return Foo(self.x + other.x) } operator == (other: Foo): bool { return self.x == other.x } fun Foo(x: int) { self.x = x } } Traits You can also define operators for traits . This is useful if you want to define operators for multiple types. trait Add { operator + (other: Self): Self } struct Foo { x: int, } impl Foo trait Add { operator + (other: Foo): Foo { return Foo(self.x + other.x) } } Overloadable operators The following operators can be overloaded: + - * / % == != < > <= >= ! && || & | [","title":"3. Overloading"},{"location":"tutorial/advanced/overloads/#operator-overloading","text":"\u26a0\ufe0f This feature is unlikely to ever be implemented \u26a0\ufe0f: Source code should work the way you expect it to. Operator overloads may cause a lot of confusion. TLDR: bad This is a feature that allows you to define the behavior of operators when applied to your own types. For example, you can define what happens when you add two instances of your class together, or when you compare them for equality.","title":"Operator Overloading"},{"location":"tutorial/advanced/overloads/#syntax","text":"Operator overloading is done inside the impl block of a type. The operator is defined using the operator keyword. struct Foo { x: int, } impl Foo { operator + (other: Foo): Foo { return Foo(self.x + other.x) } operator == (other: Foo): bool { return self.x == other.x } fun Foo(x: int) { self.x = x } }","title":"Syntax"},{"location":"tutorial/advanced/overloads/#traits","text":"You can also define operators for traits . This is useful if you want to define operators for multiple types. trait Add { operator + (other: Self): Self } struct Foo { x: int, } impl Foo trait Add { operator + (other: Foo): Foo { return Foo(self.x + other.x) } }","title":"Traits"},{"location":"tutorial/advanced/overloads/#overloadable-operators","text":"The following operators can be overloaded: + - * / % == != < > <= >= ! && || & | [","title":"Overloadable operators"},{"location":"tutorial/advanced/traits/","text":"Traits \u26a0\ufe0f Will be implemented together with generics in future updates \u26a0\ufe0f Traits are a way to define a set of methods that a type can implement. Traits are similar to interfaces in other languages. Also see Generics , where traits are used to define constraints on type parameters. Syntax Traits are declared using the trait keyword. The methods are declared using the fun keyword. trait Foo { fun foo(name: string) fun bar()!: int } Implementing traits A type can implement a trait using the impl keyword. The methods are implemented using the fun keyword. impl Bar trait Foo { fun foo(name: string) { io.println(\"Hello, \" + name) } fun bar()!: int { anEvilFunctionThatCrashesTheProgramOnFriday() return 34 } } Trait constraints Traits can be used as constraints on type parameters. This means that the type parameter must implement the trait. First we define a trait: trait Animal { fun speak() } Then we define two types that implement the trait: struct Dog { name: string, } impl Dog trait Animal { fun speak() { io.println(\"Woof!\") } } struct Cat { name: string, } impl Cat trait Animal { fun speak() { io.println(\"Meow!\") } } Don't forget to implement a constructor for each type. Then we can write a pair structure that can hold any two types that implement the Animal trait: struct Pair<T(Animal), U(Animal)> { x: T, y: U, } impl Pair { fun Pair(x: T, y: U) { this.x = x this.y = y } } Using this structure, we can create a pair of a dog and a cat: fun main() { let pair = Pair(Dog(\"Fido\"), Cat(\"Mittens\")) pair.x.speak() pair.y.speak() } // Output: // Woof! // Meow!","title":"2. Traits"},{"location":"tutorial/advanced/traits/#traits","text":"\u26a0\ufe0f Will be implemented together with generics in future updates \u26a0\ufe0f Traits are a way to define a set of methods that a type can implement. Traits are similar to interfaces in other languages. Also see Generics , where traits are used to define constraints on type parameters.","title":"Traits"},{"location":"tutorial/advanced/traits/#syntax","text":"Traits are declared using the trait keyword. The methods are declared using the fun keyword. trait Foo { fun foo(name: string) fun bar()!: int }","title":"Syntax"},{"location":"tutorial/advanced/traits/#implementing-traits","text":"A type can implement a trait using the impl keyword. The methods are implemented using the fun keyword. impl Bar trait Foo { fun foo(name: string) { io.println(\"Hello, \" + name) } fun bar()!: int { anEvilFunctionThatCrashesTheProgramOnFriday() return 34 } }","title":"Implementing traits"},{"location":"tutorial/advanced/traits/#trait-constraints","text":"Traits can be used as constraints on type parameters. This means that the type parameter must implement the trait. First we define a trait: trait Animal { fun speak() } Then we define two types that implement the trait: struct Dog { name: string, } impl Dog trait Animal { fun speak() { io.println(\"Woof!\") } } struct Cat { name: string, } impl Cat trait Animal { fun speak() { io.println(\"Meow!\") } } Don't forget to implement a constructor for each type. Then we can write a pair structure that can hold any two types that implement the Animal trait: struct Pair<T(Animal), U(Animal)> { x: T, y: U, } impl Pair { fun Pair(x: T, y: U) { this.x = x this.y = y } } Using this structure, we can create a pair of a dog and a cat: fun main() { let pair = Pair(Dog(\"Fido\"), Cat(\"Mittens\")) pair.x.speak() pair.y.speak() } // Output: // Woof! // Meow!","title":"Trait constraints"}]}